######################################
1.IRQ (irq.c)
######################################
static irqreturn_t irq_handler
(	int _1
,	void * _2
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
,	struct pt_regs * _3
#endif
)
{
	atomic_inc(&l.s.irq);

	size_t completes = 0, i;

	for (i = 0; i < l.nsubsystems; ++i)
	{
		if ((irq_subsystem_arr[i].handler)() == IRQ_HANDLED)
		{
			++completes;
			atomic_inc(&l.s.irq_arr[i]);
		}
	}

	if (!completes)
	{
		atomic_inc(&l.s.unknown_irq);
		return IRQ_NONE;
	}
	else{
	reg_locked_set(m.pci.reg.irq_ctrl, LSD_RICB_IRQCLR); //add vicg!!!!
	}

	return IRQ_HANDLED;
}


######################################
1.MEM (mem.c)
######################################
int setup(void)
{
	// reset and wait "ready" mark

if (!(reg_locked_get(m.pci.reg.dev.status) & LSD_RDSB_MEM_READY))
{
	reg_lock();
	reg_set(m.pci.reg.ctrl, reg_get(m.pci.reg.ctrl) | LSD_RCB_MEM_RESET); //change vicg
	reg_unlock();

	msleep(1);

	reg_lock();
	reg_set(m.pci.reg.ctrl, reg_get(m.pci.reg.ctrl) & ~LSD_RCB_MEM_RESET); //change vicg
	reg_unlock();

  msleep(1);

	const unsigned long j0 = jiffies;

	while (1)
	{
		if (reg_locked_get(m.pci.reg.dev.status) & LSD_RDSB_MEM_READY)
			break;

		if (jiffies_to_msecs(jiffies - j0) > 10000) //change vicg
			return -EIO;

		if (msleep_interruptible(1))
			return -ERESTARTSYS;
	}
}
	// setup mem.ctrl

	reg_lock();
	{
		u32 reg = reg_get(m.pci.reg.mem.ctrl);

		reg &= ~(LSD_RMC_WR_SIZE | LSD_RMC_RD_SIZE);
		reg |= (LSD_MEM_TRANS_WR << LSD_RMCO_WR_SIZE) & LSD_RMC_WR_SIZE;
		reg |= (LSD_MEM_TRANS_RD << LSD_RMCO_RD_SIZE) & LSD_RMC_RD_SIZE;

		reg_set(m.pci.reg.mem.ctrl, reg);
	}
	reg_unlock();

	return 0;
}